package com.nestor.elements {		import flash.display.MovieClip;	import flash.events.Event;	import flash.display.BitmapData;	import flash.display.Bitmap;	import flash.geom.Matrix;	import flash.filters.DisplacementMapFilter;	import flash.geom.Point;	public class maskedDisplacement extends MovieClip {		var wide:Number;		var high:Number;		var perlin:MovieClip = new MovieClip();		public var speedX; // speed at which noise is shifted (causes flap)		public var speedY; // speed at which noise is shifted (causes flap)		public var channel = 1;		// DISPLACEMENT variables		public var flapX; // power of pixel displacement along x axis		public var flapY; // power of pixel displacement along y axis		var mode = "clamp"; // clamp the image so none of the original is seen		var displaceBitmap:BitmapData;		var displaceFilter:DisplacementMapFilter;		var ramp:MovieClip;		var target:MovieClip;		var displace:MovieClip;		var offset = new flash.geom.Point(0, 0);		public var baseX; // size of noise in x axis		public var baseY; // size of noise in y axis		public var octs = 1; // noise functions for noise (smaller = faster)		public var seed = Math.floor(Math.random() * 50); // random seed for noise		var stitch = true; // stitching makes the noise wrap making it easy to repeat		var fractal = true; // use fractal noise		var gray = true; // grayscale is not used because the red channel is		public var noiseWidth:Number;		public var noiseLength:Number;		var noiseBitmap:BitmapData;		var shift:Matrix = new Matrix();				public function maskedDisplacement() {			// constructor code				}						[Inspectable(defaultValue=displace_mc)]		public function set displacMovieClip(dmc:MovieClip):void {			displace = dmc;		} 				[Inspectable(defaultValue=target_mc)]		public function set targetMovieClip(tmc:MovieClip):void {			target = tmc;		} 				[Inspectable(defaultValue=200)]		public function set displaceX(X:Number):void {			flapX = X;		}				[Inspectable(defaultValue=0)]		public function set displaceY(Y:Number):void {			flapY = Y;		}				[Inspectable(defaultValue=200)]		public function set shiftSpeedX(X:Number):void {			speedX = X;		}		[Inspectable(defaultValue=0)]		public function set shiftSpeedY(Y:Number):void {			speedY = Y;		}				[Inspectable(defaultValue=1000)]		public function set noiseSizeX(X:Number):void {			baseX = X;		}				public function get noiseSizeX():Number {			return baseX;		}				[Inspectable(defaultValue=1000)]		public function set noiseSizeY(Y:Number):void {			baseY = Y;		}		public function get noiseSizeY():Number {			return baseY;		}				[Inspectable(defaultValue=50)]		public function set noiseSeed(S:Number):void {			seed = Math.floor(Math.random() * 50);		}				[Inspectable(defaultValue=10)]		public function set noiseBM_width(W:Number):void {			noiseWidth = W;		}		[Inspectable(defaultValue=10)]		public function set noiseBM_height(H:Number):void {			noiseLength = H;		}				public function link(_targetMC:MovieClip, _displace:MovieClip)		{			target = _targetMC;			displace = _displace;			wide = displace.width;			high = displace.height;		}				public function build():void		{			displace.visible = false;			displace.addChildAt(perlin, 1);			ramp = displace.ramp;			displace.swapChildren(perlin, ramp);			displaceBitmap = new BitmapData(wide, high);			displaceFilter = new DisplacementMapFilter(displaceBitmap, offset, channel, channel, flapX, flapY, mode);						// create BitmapData object for the noise and apply perlinNoise.  It will be repeated			// along y so it  only needs to be 1 pixel high.  How long it is determines the			// variants of noise produced.  With the stitching and thanks to beginGradientFill,			// we will just loop the noise over time.			noiseBitmap = new BitmapData(noiseWidth, noiseLength);			noiseBitmap.perlinNoise(baseX, baseY, octs, seed, stitch, fractal, channel, gray);		}				public function start():void		{			this.addEventListener(Event.ENTER_FRAME,loop);		}				public function loop(evt:Event):void{				// move the matrix by speed along x to shift the noise			shift.translate(speedX, speedY);						// drawing in the perlin movie clip,			// create a rectangle with the perlin noise			// drawn in it with an offset supplied by the			// shift matrix			with (this.displace.graphics){				clear();				beginBitmapFill(noiseBitmap, shift);				moveTo(0,0);				lineTo(wide, 0);				lineTo(wide, high);				lineTo(0, wide);				lineTo(0, 0);				endFill();			}			// draw the displacement movie clip in the 			// displaceBitmap (used in displaceFilter)			displaceBitmap.draw(displace);			// apply displaceFilter to the flag			target.filters = [displaceFilter];		}	}	}/*Stage.scaleMode = 'noScale';Here, perlin noise is used to create random waves in a movie clip that is used as a displacement map for aflag movie clip making it appear as though it is waving*/// create a movie clip in displace_mc to// draw perlin noise in//displace_mc.createEmptyMovieClip("perlin", 1);// ramp is a movie clip already in displace_mc that is// used to ease the perlin noise from non effective on the// left side of the flag to fully effective on the right//var ramp:MovieClip = this.water_mc.displace_mc.ramp//ramp.swapDepths(2); // place ramp above perlin noise// ** 50% red is no displacement in the displacement map// the ramp goes from 50% red to transparent letting// the perlin noise show through as you move further right// GENERAL variables// ** inside the flag movie clip there is an invisible border that is// used to extend the bounds of the clip beyond that of the flag image// this lets the displacement map extend further past the extents of the flag // displacment map offset// create BitmapData object encompasing the size of the displace ramp// for the displacement and create a displace filter that uses it// PERLINNOISE variables// the shift matrix allows for the noise to be moved over time// using beginBitmapFill since the noise is only created once// and just looped for the flag effect// every frame//stage.addEventListener(MouseEvent.MOUSE_DOWN, down);// stage.addEventListener(MouseEvent.MOUSE_UP, up);// show the displacement image when the mouse is pressed/*function down(evt:MouseEvent):void{	displace_mc.visible = true;	sail_mc.visible = false;}// go back to showing main image when the mouse is releasedfunction up(evt:MouseEvent):void{	displace_mc.visible = false;	sail_mc.visible = true;}*/