package com.nestor.sxc.imap{	import flash.events.Event;	import flash.events.IOErrorEvent;	import flash.events.SecurityErrorEvent;	import flash.events.DatagramSocketDataEvent;		//import com.greensock.TweenLite; 	//import com.greensock.easing.*;	import flash.events.EventDispatcher;	import flash.events.MouseEvent;	import flash.display.MovieClip;	import flash.net.DatagramSocket;	import flash.utils.ByteArray;	//import com.sweetandfizzy.siouxcity.*;	//import flash.geom.Rectangle;	//import flash.geom.Point;		public class UDPController extends MovieClip {		// this block defines events that the controller (includes buttons & wheel) will send to the interactive:/*		public static const OLED1PRESSED:String="oled1down";		public static const OLED2PRESSED:String="oled2down";		public static const OLED3PRESSED:String="oled3down";		public static const OLED4PRESSED:String="oled4down";		public static const OLED1RELEASED:String="oled1up";		public static const OLED2RELEASED:String="oled2up";		public static const OLED3RELEASED:String="oled3up";		public static const OLED4RELEASED:String="oled4up";		public static const BACKBTNPRESSED:String="backIsdown";		public static const BACKBTNRELEASED:String="backIsup";		public static const WHEELCHANGED:String="wheelChanged";*/				//public var wheelDelta;		public var msg:String;		private var udpHost:String = "127.0.0.1"; //Please set these with a config file		private var udpSendPort:int = 4455;    //Please set these with a config file		private var udpRecPort:int = 5566;    //Please set these with a config file				//Setup two sockets, one for send, one for receive.		private var outlet:DatagramSocket = new DatagramSocket();		private var inlet:DatagramSocket = new DatagramSocket();		public var deltaWheel:Number; //Wheel Speed and direction.  -30 ~ 30				// wheelValue is a range from 0-360, currently it loops after 360 back to 0;		public var wheelValue:Number;		public var wheelCycles:Number;				// currentYear gets updated on every frame when timeline pointer has moved, to reflect the year the timeline is currently pointing to.		public var currentYear:uint;				// OLEDimageStrings holds the current images or swf path for each OLED to display.		public var OLEDimageStrings:Array;		//private var OLEDarray:Array;				// tog1-tog4: these are just for utility— temporary functionality that toggles the OLED states on each press.		/*public var tog1:Boolean = false;		public var tog2:Boolean = false;		public var tog3:Boolean = false;		public var tog4:Boolean = false;		*/		// initialTurnAngle, currentTurnAngle:  used for continuity of movement for my virtual wheel		private var initialTurnAngle:Number;		private var currentTurnAngle:Number;				// k is a constant I use to convert radians to degrees		private var k:Number  = 180/Math.PI;/**/				public function UDPController(host:String, tx:int, rx:int) {			// These event listeners are for my virtual buttons and wheel			/*oled1.buttonMode = true; 			oled2.buttonMode = true; 			oled3.buttonMode = true; 			oled4.buttonMode = true; */			/*oled1.addEventListener(MouseEvent.MOUSE_DOWN, pressOLED1);			oled2.addEventListener(MouseEvent.MOUSE_DOWN, pressOLED2);			oled3.addEventListener(MouseEvent.MOUSE_DOWN, pressOLED3);			oled4.addEventListener(MouseEvent.MOUSE_DOWN, pressOLED4);			oled1.addEventListener(MouseEvent.MOUSE_UP, releaseOLED1);			oled2.addEventListener(MouseEvent.MOUSE_UP, releaseOLED2);			oled3.addEventListener(MouseEvent.MOUSE_UP, releaseOLED3);			oled4.addEventListener(MouseEvent.MOUSE_UP, releaseOLED4);			backBtn.addEventListener(MouseEvent.MOUSE_DOWN, pressBack);			backBtn.addEventListener(MouseEvent.MOUSE_UP, releaseBack);			knob.addEventListener(MouseEvent.MOUSE_DOWN, startTurning);			knob.addEventListener(MouseEvent.MOUSE_UP, stopTurning);*/			udpHost = host; //Please set these with a config file			udpSendPort = tx;    //Please set these with a config file			udpRecPort = rx;    //Please set these with a config file					OLEDimageStrings = new Array();			wheelCycles = 0;						initUDP();		}				public function setBrake(drag:Number):void {			trace("setBrake( "+drag+" )");			var wheelCmd:String = "brake;"+drag.toString();			sendCmd(wheelCmd);		}				public function setLed(LEDState:Number):void {			trace("setLed( LEDState: "+LEDState+" )");			var ledCmd:String = "led;"+LEDState.toString();			sendCmd(ledCmd);		}				public function setImg(swId:Number,imgId:Number):void {			trace("setImg( swId: "+swId+" imgId: "+imgId+" )");			var imgCmd:String = "led;"+swId.toString()+";"+imgId.toString();			sendCmd(imgCmd);		}								//Replaced above.. image location will be an index, not a path.				// updateOLEDimage function is called from the interactive, and tells the controller class which OLED image to change, and the file path for the new image:		/*public function updateOLEDimage(OLEDindex:uint, imagePath:String):void {			OLEDimageStrings[OLEDindex]=imagePath;		}*/				//accepts a (hopefully)well-formed message and sends it as UTF Bytes, appending EOL char.		public function sendCmd(cmd:String):void {			var EOL:String = "\n"; //Newline			//var EOL:String = "\r"; //Carriage Return			trace("Sending :"+cmd+"on "+udpHost+":"+udpSendPort);			var bytes:ByteArray=new ByteArray();			bytes.writeUTFBytes(cmd+EOL);			outlet.send(bytes,0,0,udpHost,udpSendPort);		}				public function initUDP():void {			trace("initUDP");			inlet.addEventListener(DatagramSocketDataEvent.DATA, dataHandler);       		inlet.addEventListener(IOErrorEvent.IO_ERROR, IOErrorHandler);      		inlet.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);			       		inlet.bind(udpRecPort, "127.0.0.1");						//datagramSocket.receive();			inlet.receive();			trace("UDP Inlet: waiting for connection");		}						private function dataHandler(e:DatagramSocketDataEvent) : void {			trace("dataHandler( "+e+" )");				msg = e.data.readUTFBytes(e.data.length);				dispatchEvent(new Event("hello"));				var cmd:Array = msg.split(";");  //Field separator for messages is ";"								switch (cmd[0]) {//sort commands by "domain"									case "sw":					swHandler(cmd[1], cmd[2]);					break;										case "wheel":					 deltaWheel= cmd[1];					 					// tweenWheel(deltaWheel);   // for now, we can get tweened changes by using this function. when using the real wheel, the turnedWheel funciion will be used instead.					// turnedWheel(deltaWheel);					 					break;									}		}					/*private function tweenWheel(changeAngle:Number):void {			trace("tweenWheel( "+changeAngle+" )");			TweenLite.to( this, .3, { wheelValue:changeAngle, ease:Quad.easeInOut, onUpdate:function(){ dispatchEvent(new Event("wheelChanged")); } } );		}		private function turnedWheel(changeAngle:Number):void {			trace("turnedWheel( "+changeAngle+" )");			wheelValue+=changeAngle;			dispatchEvent(new Event("wheelChanged"));		}*/				private function IOErrorHandler(event:IOErrorEvent) : void {			trace("IOErrorHandler( "+event+" )");			//trace(event);		}				private function securityErrorHandler(event:SecurityErrorEvent) : void {			trace("securityErrorHandler( "+event+" )");			//trace(event);		}				//Parses out the rest of the sw;x;x command		private function swHandler(id:String, swState:String) {			trace("swHandler( id: "+id+", swState: "+swState+" )");						var btnState:String;    //.substr(0,1) strips hidden line break after first character in btnState string -- param 0 starts at beginning of string and param'1' is how many characters			if (swState.substr(0,1)=="0") btnState="Up" else btnState="Down";			// ...the following line does the same as the two lines above, but is not as easy to read:						//var btnState:String = swState.substr(0,1)=="0" ? "Up" : "Down";			var btnFunction:String="remoteBtn"+id+btnState;			trace("Calling function: "+btnFunction+"()");			//this[btnFunction]();		}						// these remote control functions are a way to virtually press these virtual buttons. With them you can varify if your hardware buttons are pressed, by having your hardware handlers call these functions		/*private function remoteBtn1Down():void { oled1.dispatchEvent(new MouseEvent(MouseEvent.MOUSE_DOWN)); trace("remoteBtn1Down");}		private function remoteBtn2Down():void { oled2.dispatchEvent(new MouseEvent(MouseEvent.MOUSE_DOWN)); 	}		private function remoteBtn3Down():void { oled3.dispatchEvent(new MouseEvent(MouseEvent.MOUSE_DOWN)); 	}		private function remoteBtn4Down():void { oled4.dispatchEvent(new MouseEvent(MouseEvent.MOUSE_DOWN)); 	}		private function remoteBtn5Down():void { backBtn.dispatchEvent(new MouseEvent(MouseEvent.MOUSE_DOWN)); }		//Changed "BAck" to 5, for repeatibility.		private function remoteBtn1Up():void { oled1.dispatchEvent(new MouseEvent(MouseEvent.MOUSE_UP)); 	trace("remoteBtn1Up");}		private function remoteBtn2Up():void { oled2.dispatchEvent(new MouseEvent(MouseEvent.MOUSE_UP)); }		private function remoteBtn3Up():void { oled3.dispatchEvent(new MouseEvent(MouseEvent.MOUSE_UP)); }		private function remoteBtn4Up():void { oled4.dispatchEvent(new MouseEvent(MouseEvent.MOUSE_UP)); }		private function remoteBtn5Up():void { backBtn.dispatchEvent(new MouseEvent(MouseEvent.MOUSE_UP)); }*///These function dispatches custom Events, relaying the MouseEvents from the controller to the interactive:/*		private function pressOLED1(e:MouseEvent):void {			//tog1 = !tog1;		oled1.gotoAndStop("_down");		dispatchEvent(new Event("oled1down"));		}		private function pressOLED2(e:MouseEvent):void {			//tog2 = !tog2;		oled2.gotoAndStop("_down");		// This illustrates remote function control of these virtual buttons, ie ,		remoteBtn1Down();  // oled2 mouse down event dispatches oled1 mouse up. You can comment out			dispatchEvent(new Event("oled2down"));		}		private function pressOLED3(e:MouseEvent):void {			//tog3 = !tog3;		oled3.gotoAndStop("_down");	dispatchEvent(new Event("oled3down"));		}		private function pressOLED4(e:MouseEvent):void {			//tog4 = !tog4;			oled4.gotoAndStop("_down");			dispatchEvent(new Event("oled4down"));		}		private function releaseOLED1(e:MouseEvent):void {			tog1 = !tog1;			//oled1.gotoAndStop("_up");			dispatchEvent(new Event("oled1up"));		}		private function  releaseOLED2(e:MouseEvent):void {			tog2 = !tog2;			remoteBtn1Up();  // oled2 mouse up event dispatches oled1 mouse down. Comment out or delete call			//oled2.gotoAndStop("_up");			dispatchEvent(new Event("oled2up"));		}		private function  releaseOLED3(e:MouseEvent):void {			tog3 = !tog3;			//oled3.gotoAndStop("_up");			dispatchEvent(new Event("oled3up"));		}		private function  releaseOLED4(e:MouseEvent):void {			tog4 = !tog4;			//oled4.gotoAndStop("_up");			dispatchEvent(new Event("oled4up"));		}		private function pressBack(e:MouseEvent):void {			backBtn.gotoAndStop("_down");			dispatchEvent(new Event("backIsdown"));		}		private function releaseBack(e:MouseEvent):void {			backBtn.gotoAndStop("_up");			dispatchEvent(new Event("backIsup"));		}						// events and dispatches for the virtual wheel functionality		private function startTurning(e:MouseEvent):void {			knob.addEventListener(MouseEvent.MOUSE_MOVE, updateWheel);			knob.addEventListener(MouseEvent.MOUSE_OUT, stopTurning);			initialTurnAngle = rotationAngle(knob.mouseX, knob.mouseY); // retrieves relative angle of mouse to wheel axis		}		private function stopTurning(e:MouseEvent):void {			knob.removeEventListener(MouseEvent.MOUSE_OUT, stopTurning);			knob.removeEventListener(MouseEvent.MOUSE_MOVE, updateWheel);		}		private function updateWheel(e:MouseEvent):void {			// This function could be messed with to provide visual feedback of vitual knob turning, for testing purposes.			// 						currentTurnAngle = rotationAngle(knob.mouseX, knob.mouseY);  // retrieves relative angle of mouse to wheel axis			//trace(initialTurnAngle, currentTurnAngle);			var turnDifference:Number = currentTurnAngle-initialTurnAngle;   // this is the angle the wheel has turned since last call to updateWheel			if ( turnDifference>180 ) turnDifference-=360;			if ( turnDifference<-180 ) turnDifference+=360; // this line and line above keeps turnDifference between -180 and +180 range			//trace(turnDifference);			knob.wheel.rotation += turnDifference; // knob is a holder for the wheel, which is the part that rotates. I parented wheel to knob to get the mouse coordinates without need for conversion: ie axis is zero in knob mouse space.			//wheelValue = (knob.wheel.rotation+currentTurnAngle-initialTurnAngle+360)%360;  // the +360 . . . %360 is a way to normalise the wheelvalue so it always falls between 0-360			wheelValue+=turnDifference;			initialTurnAngle=currentTurnAngle;			//trace(knob.wheel.rotation, wheelValue);			// I don't send the value of the wheel with this event dispatch: It is easier to have the interactive program event listener just get the variable 'controller.wheelValue' directly from the controller			dispatchEvent(new Event("wheelChange"));		}				/// this function calulates a rotation value (trig angle) based on the mouse offsets from the wheel axis		private function rotationAngle(dx:Number, dy:Number):Number {  			return Math.atan2(dy, dx) * k;		}*/	}	}